<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USAmath Christian CHESS APP - V5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&family=Roboto+Mono:wght+400;700&display=swap');
        
        body { font-family: 'Noto Sans', sans-serif; touch-action: manipulation; }
        .chess-piece { cursor: grab; user-select: none; z-index: 10; }
        
        /* Board Highlights */
        .square.selected { background-color: rgba(255, 255, 0, 0.5) !important; }
        .square.last-move { background-color: rgba(155, 199, 0, 0.41) !important; }
        .square.possible-move::after {
            content: ''; position: absolute; width: 12px; height: 12px;
            background-color: rgba(0, 0, 0, 0.2); border-radius: 50%;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .square.capture-move::after {
            content: ''; position: absolute; width: 100%; height: 100%;
            border: 4px solid rgba(0, 0, 0, 0.2); border-radius: 50%;
            top: 0; left: 0; box-sizing: border-box;
        }

        /* Eval Bar */
        .eval-bar-container {
            width: 24px; height: 100%; background: #404040;
            border-radius: 4px; overflow: hidden; position: relative;
            border: 1px solid #555; transition: opacity 0.3s;
        }
        .eval-fill {
            width: 100%; background: white; position: absolute; bottom: 0;
            transition: height 0.5s ease-in-out;
        }
        .eval-text {
            position: absolute; width: 100%; text-align: center;
            font-size: 10px; font-weight: bold; z-index: 10;
            mix-blend-mode: difference; color: #aaa; 
            top: 50%; transform: translateY(-50%);
        }

        #board-overlay { pointer-events: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; }
        
        /* Message Box */
        #message-box {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #f97316; color: white; padding: 12px 24px;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 100; font-weight: bold; opacity: 0; visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        #message-box.show { opacity: 1; visibility: visible; }
        
        .mode-radio:checked + label { background-color: #f59e0b; color: #1e293b; border-color: #d97706; }
        #promotion-modal { backdrop-filter: blur(5px); }
        .promo-option { font-size: 3rem; cursor: pointer; transition: transform 0.1s; }
        .promo-option:hover { transform: scale(1.2); }

        /* Toggle Switch */
        .toggle-checkbox:checked { right: 0; border-color: #10B981; }
        .toggle-checkbox:checked + .toggle-label { background-color: #10B981; }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen flex flex-col items-center p-2 sm:p-4">

    <div class="w-full max-w-6xl flex flex-col lg:flex-row gap-6 justify-center items-start">
        
        <!-- Left Column: Board & Eval -->
        <div class="flex gap-2 w-full lg:w-auto justify-center">
            
            <div id="eval-bar-wrapper" class="h-[480px] hidden sm:flex flex-col items-center justify-center py-1 transition-opacity duration-300">
                <div class="eval-bar-container shadow-lg">
                    <div id="eval-fill" class="eval-fill" style="height: 50%;"></div>
                    <div id="eval-score" class="eval-text">0.0</div>
                </div>
            </div>

            <!-- Main Board Area -->
            <div class="flex flex-col gap-2 w-full max-w-[480px]">
                
                <!-- Header -->
                <div class="bg-slate-800 p-3 rounded-xl border border-slate-700 flex justify-between items-center shadow-lg">
                    <h1 class="text-xl font-bold text-white flex items-center gap-2">
                        <img src="./apple-touch-icon.png" alt="Logo" class="h-8 w-8 rounded-full border-2 border-amber-500" onerror="this.src='https://placehold.co/40x40/1e293b/f59e0b?text=C'; this.onerror=null;">
                        <span class="text-amber-400">USAmath Chess</span>
                    </h1>
                    <div class="flex items-center gap-3">
                         <div class="flex items-center gap-2">
                            <span class="text-xs font-bold text-slate-400">METRICS</span>
                            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" id="metrics-toggle" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600 transition-all duration-300 left-0 checked:left-5 checked:border-emerald-500" checked onclick="toggleMetrics()">
                                <label for="metrics-toggle" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer transition-colors duration-300 checked:bg-emerald-500"></label>
                            </div>
                        </div>
                        <div id="status-badge" class="text-sm font-bold px-3 py-1 bg-slate-700 rounded text-white border border-slate-600">White's Turn</div>
                    </div>
                </div>

                <!-- Stockfish Coach Box (New) -->
                <div id="coach-box" class="bg-slate-800 p-3 rounded border border-slate-700 shadow-inner transition-opacity duration-300 min-h-[50px] flex items-center justify-center">
                    <p id="coach-text" class="text-sm font-mono text-center text-amber-100">
                        <span class="text-emerald-400 font-bold">Stockfish Coach:</span> Game Start. Waiting for moves...
                    </p>
                </div>

                <!-- Board Wrapper -->
                <div class="relative w-full aspect-square bg-slate-700 rounded-lg shadow-2xl border-4 border-slate-700 overflow-hidden select-none">
                    <div id="board" class="grid grid-cols-8 grid-rows-8 w-full h-full z-10 relative"></div>
                    <svg id="board-overlay" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
                    <div id="game-over-modal" class="hidden absolute inset-0 bg-black/70 z-50 flex flex-col items-center justify-center backdrop-blur-sm">
                        <h2 id="game-result" class="text-3xl font-bold text-white mb-2">Game Over</h2>
                        <button onclick="resetGame()" class="bg-amber-500 hover:bg-amber-600 text-white px-6 py-2 rounded-full font-bold shadow-lg transition transform hover:scale-105">Play Again</button>
                    </div>
                </div>

                <!-- Evaluation Graph -->
                <div id="graph-container" class="w-full h-24 bg-slate-800 rounded border border-slate-700 relative overflow-hidden transition-opacity duration-300">
                    <canvas id="evalGraph" class="w-full h-full block"></canvas>
                    <div class="absolute top-1 left-2 text-[10px] text-slate-500 font-mono pointer-events-none">EVALUATION GRAPH</div>
                </div>

                <!-- Controls -->
                <div class="grid grid-cols-5 gap-2">
                    <button onclick="startEngine()" class="bg-emerald-700 hover:bg-emerald-600 text-white py-2 rounded text-sm font-bold border border-emerald-600 transition shadow-md">▶ Start</button>
                    <button onclick="stopEngineManually()" class="bg-red-700 hover:bg-red-600 text-white py-2 rounded text-sm font-bold border border-red-600 transition shadow-md">⬛ Stop</button>
                    <button onclick="flipBoard()" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-sm font-medium border border-slate-600 transition shadow-sm">Flip</button>
                    <button onclick="undoMove()" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-sm font-medium border border-slate-600 transition shadow-sm">Undo</button>
                    <button onclick="resetGame()" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-sm font-medium border border-slate-600 transition shadow-sm">New</button>
                </div>
                
                <div class="bg-slate-800 p-2 rounded border border-slate-700 text-xs font-mono text-slate-400 flex justify-between items-center shadow-inner">
                    <span id="engine-status-text">Engine: Loading...</span>
                    <span id="depth-text">Depth: 0</span>
                    <span id="best-move-text">Best: -</span>
                </div>
            </div>
        </div>

        <!-- Right Column: Settings -->
        <div class="w-full lg:w-80 flex flex-col gap-4">
            
            <!-- Game Settings -->
            <div class="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-lg">
                <h2 class="text-sm uppercase tracking-wider font-bold text-slate-400 mb-3">Settings</h2>
                <div class="grid grid-cols-2 gap-3 mb-4">
                    <div>
                        <label class="text-xs text-slate-500 block mb-1 font-bold">White</label>
                        <select id="white-player" onchange="updateSettings()" class="w-full bg-slate-900 text-white text-sm p-2 rounded border border-slate-600 outline-none focus:border-amber-500 transition">
                            <option value="human">Human</option>
                            <option value="stockfish">Engine</option>
                        </select>
                    </div>
                    <div>
                        <label class="text-xs text-slate-500 block mb-1 font-bold">Black</label>
                        <select id="black-player" onchange="updateSettings()" class="w-full bg-slate-900 text-white text-sm p-2 rounded border border-slate-600 outline-none focus:border-amber-500 transition">
                            <option value="stockfish">Engine</option>
                            <option value="human">Human</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Engine Configuration (UPDATED) -->
            <div class="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-lg">
                <h2 class="text-sm uppercase tracking-wider font-bold text-amber-400 mb-3">Engine Configuration</h2>
                
                <!-- Speed Controls -->
                <div class="flex mb-4">
                    <input type="radio" id="mode-time" name="engine-mode" value="time" class="hidden mode-radio" checked onchange="updateEngineModeDisplay()">
                    <label for="mode-time" class="flex-1 text-center text-xs font-bold p-2 rounded-l-lg cursor-pointer transition bg-slate-700 text-slate-300 border border-r-0 border-slate-600">
                        Fast (Time)
                    </label>
                    <input type="radio" id="mode-depth" name="engine-mode" value="depth" class="hidden mode-radio" onchange="updateEngineModeDisplay()">
                    <label for="mode-depth" class="flex-1 text-center text-xs font-bold p-2 rounded-r-lg cursor-pointer transition bg-slate-700 text-slate-300 border border-slate-600">
                        Deep (Depth)
                    </label>
                </div>

                <div id="time-control-group" class="mb-4">
                    <label class="text-xs text-slate-500 block mb-1 font-bold">Max Time (Milliseconds)</label>
                    <input type="number" id="engine-time-ms" value="1000" min="100" step="100" 
                           class="w-full bg-slate-900 text-white text-sm p-2 rounded border border-slate-600 outline-none focus:border-amber-500 transition"
                           onchange="onConfigChange()">
                </div>

                <div id="depth-control-group" class="mb-4 hidden">
                    <label class="text-xs text-slate-500 block mb-1 font-bold">Fixed Depth</label>
                    <input type="number" id="engine-depth-val" value="15" min="5" max="30" 
                           class="w-full bg-slate-900 text-white text-sm p-2 rounded border border-slate-600 outline-none focus:border-amber-500 transition"
                           onchange="onConfigChange()">
                </div>

                <!-- Analysis Arrows (MultiPV) -->
                <div class="pt-3 border-t border-slate-700">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-xs text-slate-500 font-bold">Engine Arrows (1-5)</label>
                        <span id="multipv-display" class="text-xs font-mono text-amber-400 font-bold">1</span>
                    </div>
                    <input type="range" id="multipv-slider" min="1" max="5" value="1" 
                           class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-emerald-500" 
                           oninput="onMultiPvChange()">
                </div>

                <!-- Skill Level -->
                <div class="mt-4 pt-3 border-t border-slate-700">
                    <div class="flex justify-between items-end mb-1">
                        <label class="text-xs text-slate-500 font-bold">Skill Level (ELO)</label>
                        <span id="elo-display" class="text-xs font-mono text-amber-400 font-bold">1500</span>
                    </div>
                    <input type="range" id="elo-slider" min="0" max="20" value="10" 
                           class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-amber-500" 
                           oninput="updateEloDisplay()">
                </div>
            </div>

            <!-- Game Modes -->
            <div class="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-lg">
                <h2 class="text-sm uppercase tracking-wider font-bold text-slate-400 mb-3">Game Modes</h2>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <button onclick="setGameMode('classical')" id="btn-classical" class="bg-amber-500 text-slate-900 font-bold py-2 rounded transition">Classical</button>
                    <button onclick="setGameMode('960')" id="btn-960" class="bg-slate-700 text-slate-400 font-bold py-2 rounded transition hover:bg-slate-600">Chess 960</button>
                </div>
                <div id="960-controls" class="hidden pt-2 border-t border-slate-700 mt-2">
                    <div class="flex gap-2">
                        <input type="number" id="960-id" min="0" max="959" placeholder="Random ID" class="w-full bg-slate-900 text-white text-sm p-2 rounded border border-slate-600 outline-none focus:border-amber-500 transition">
                        <button onclick="startChess960()" class="bg-emerald-700 hover:bg-emerald-600 text-white px-3 rounded font-bold text-xs">GO</button>
                    </div>
                </div>
            </div>

            <div class="bg-slate-800 p-3 rounded-xl border border-slate-700 shadow-lg min-h-[60px] flex flex-col justify-center">
                <div id="captured-white" class="flex flex-wrap gap-1 text-lg leading-none mb-1"></div>
                <div id="captured-black" class="flex flex-wrap gap-1 text-lg leading-none text-slate-400"></div>
            </div>

            <div class="bg-slate-800 rounded-xl border border-slate-700 shadow-lg flex-grow overflow-hidden flex flex-col h-[300px] lg:h-auto">
                <div class="bg-slate-900/50 p-3 border-b border-slate-700 flex justify-between items-center">
                    <h2 class="text-sm font-bold text-slate-300">Move History</h2>
                    <button onclick="copyPGN()" class="text-xs text-amber-400 hover:text-amber-300 font-bold uppercase tracking-wide transition">Copy PGN</button>
                </div>
                <div id="move-history" class="flex-grow overflow-y-auto p-2 font-mono text-sm scroll-smooth">
                    <div class="text-slate-500 italic text-center mt-4">Game Start</div>
                </div>
            </div>
        </div>
    </div>

    <div id="message-box" class="fixed">Illegal Move</div>

    <div id="promotion-modal" class="hidden fixed inset-0 bg-black/80 z-[70] flex items-center justify-center p-4">
        <div class="bg-slate-800 p-6 rounded-xl border border-slate-600 shadow-2xl flex flex-col items-center">
            <h3 class="text-lg font-bold text-white mb-4">Promote Pawn</h3>
            <div class="flex gap-6" id="promo-options"></div>
        </div>
    </div>

    <script>
        const PIECES={w:{k:'♔',q:'♕',r:'♖',b:'♗',n:'♘',p:'♙'},b:{k:'♚',q:'♛',r:'♜',b:'♝',n:'♞',p:'♟'}};
        const SAN_PIECES={k:'K',q:'Q',r:'R',b:'B',n:'N',p:''};
        const ELO_MAP=[800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,2500,2700,2900,3100,3200];
        
        let board=[],turn='w',selectedSquare=null,lastMove=null,castlingRights={w:{k:true,q:true},b:{k:true,q:true}};
        let rooks960={w:{k:null,q:null},b:{k:null,q:null}},enPassantTarget=null,halfMoveClock=0,fullMoveNumber=1;
        let capturedPieces={w:[],b:[]},moveList=[],coordMoveList=[],historyStack=[],positionHistory={};
        let evalHistory=[{ply:0,score:0}], stockfish=null, isEngineReady=false;
        let isGameOver=false, isEnginePaused=true, engineTimeout=null;
        let isFlipped=false, whitePieceColor='#FFFFFF', whitePieceShadow='0 0 3px #000, 0 0 3px #000, 0 0 1px #000';
        let showMetrics=true, pendingPromotion=null, gameMode='classical';
        
        // MultiPV & Coach State
        let multiPvLines = []; // Array to store lines { id: 1, move: 'e2e4', score: 0.5, mate: null }
        let currentMultiPv = 1;
        let lastEvalScore = 0; // To track swing

        let fx=null;
        function initSound(){if(fx)return;try{fx={move:new Tone.PluckSynth({decay:0.1,sustain:0.05,release:0.1}).toDestination(),capture:new Tone.MembraneSynth({pitchDecay:0.05,octave:1,envelope:{attack:0.001,decay:0.4,sustain:0.01,release:0.1}}).toDestination(),check:new Tone.DuoSynth({voice0:{oscillator:{type:'sawtooth'}},voice1:{oscillator:{type:'sine'}},vibratoAmount:0.5}).toDestination(),mate:new Tone.PolySynth(Tone.Synth,{oscillator:{type:"triangle"}}).toDestination(),draw:new Tone.PolySynth(Tone.Synth,{oscillator:{type:"square"}}).toDestination(),action:new Tone.Synth({oscillator:{type:'sine'},envelope:{attack:0.005,decay:0.1,release:0.1}}).toDestination()};fx.thinking=new Tone.Loop(t=>fx.action.triggerAttackRelease('C4','16n',t),'4n').start(0);fx.action.volume.value=-20;fx.thinking.mute=true;}catch(e){console.error("Tone error",e);fx=false;}}
        async function playSound(t){if(!fx)return;try{await Tone.start()}catch(e){}switch(t){case'move':fx.move.triggerAttackRelease('C4','8n');break;case'capture':fx.capture.triggerAttackRelease('C2','8n');break;case'check':fx.check.triggerAttackRelease('C5','0.2');break;case'mate':fx.mate.triggerAttackRelease(['C5','E5','G5'],'0.5');break;case'draw':fx.draw.triggerAttackRelease(['A4','C5','E5'],'0.5');break;case'start':fx.action.triggerAttackRelease('G5','0.1');fx.action.triggerAttackRelease('C6','0.1','+0.1');break;case'stop':fx.action.triggerAttackRelease('C6','0.1');fx.action.triggerAttackRelease('G5','0.1','+0.1');break;case'undo':fx.action.triggerAttackRelease('F4','0.1');break;case'flip':fx.action.triggerAttackRelease('C5','0.05');break;}}
        async function toggleThinkingSound(on){if(!fx)return;fx.thinking.mute=!on;if(on){await Tone.start();fx.thinking.start(0);}}

        async function initEngine() {
            document.getElementById('engine-status-text').innerText = "Engine: Loading...";
            if(stockfish)stockfish.terminate();
            try {
                const res = await fetch('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js');
                if(!res.ok)throw new Error("SF Load Fail");
                const blob = new Blob([await res.text()],{type:'application/javascript'});
                stockfish = new Worker(URL.createObjectURL(blob));
                stockfish.postMessage('uci');
                stockfish.onmessage = (e) => {
                    const line = e.data;
                    if(line === 'uciok') {
                        isEngineReady=true; 
                        document.getElementById('engine-status-text').innerText="Engine: Ready";
                        stockfish.postMessage(`setoption name MultiPV value ${currentMultiPv}`);
                        if(gameMode==='960') stockfish.postMessage('setoption name UCI_Chess960 value true');
                        updateEloDisplay();
                    }
                    if(line.startsWith('info') && line.includes('score')) parseEngineInfo(line);
                    if(line.startsWith('bestmove')) {
                        toggleThinkingSound(false);
                        const best = line.split(' ')[1];
                        if(isComputerTurn() && !isGameOver && !isEnginePaused && best && best!=='(none)') {
                            document.getElementById('engine-status-text').innerText = "Engine: Move " + best;
                            applyEngineMove(best);
                        } else {
                            if(isEnginePaused) document.getElementById('engine-status-text').innerText = "Engine: Stopped";
                        }
                    }
                };
            } catch(e){document.getElementById('engine-status-text').innerText="Engine: Failed";}
        }

        // --- Config Handlers ---
        function updateEngineModeDisplay() {
            const mode = document.querySelector('input[name="engine-mode"]:checked').value;
            document.getElementById('time-control-group').classList.toggle('hidden', mode !== 'time');
            document.getElementById('depth-control-group').classList.toggle('hidden', mode !== 'depth');
            onConfigChange();
        }

        function onConfigChange() {
            // Stop game if setting changed as requested
            if (isEngineReady && !isEnginePaused) {
                stopEngine();
                showMessage("Settings changed - Engine Stopped");
            }
        }

        function onMultiPvChange() {
            currentMultiPv = parseInt(document.getElementById('multipv-slider').value);
            document.getElementById('multipv-display').innerText = currentMultiPv;
            if (stockfish && isEngineReady) {
                stockfish.postMessage(`setoption name MultiPV value ${currentMultiPv}`);
                // Stop to apply strictly, or just re-trigger? Requirement says "Stop the game if any change applied".
                if(!isEnginePaused) {
                    stopEngine();
                    showMessage("Arrows Changed - Engine Stopped");
                }
            }
        }

        function stopEngineManually() {
            stopEngine();
            showMessage("Engine Stopped");
        }

        function updateEloDisplay() {
            const val = parseInt(document.getElementById('elo-slider').value);
            document.getElementById('elo-display').innerText = ELO_MAP[val];
            if(stockfish && isEngineReady) stockfish.postMessage(`setoption name Skill Level value ${val}`);
        }

        // --- Evaluation & Parsing ---
        function parseEngineInfo(line) {
            if (!showMetrics) return;
            const depth = line.match(/depth (\d+)/);
            if(depth) document.getElementById('depth-text').innerText = `D: ${depth[1]}`;

            // Parse MultiPV ID (default to 1 if missing)
            let mpv = 1;
            const mpvMatch = line.match(/multipv (\d+)/);
            if(mpvMatch) mpv = parseInt(mpvMatch[1]);

            // Parse Score
            let score = 0, rawScore = 0;
            const cp = line.match(/score cp (-?\d+)/);
            const mate = line.match(/score mate (-?\d+)/);

            let scoreObj = { id: mpv, move: null, score: 0, mate: null, text: '' };

            if(mate) {
                const mVal = parseInt(mate[1]);
                rawScore = mVal > 0 ? 2000 - mVal : -2000 - mVal;
                score = rawScore;
                scoreObj.mate = mVal;
            } else if (cp) {
                rawScore = parseInt(cp[1]);
                score = (turn === 'w') ? rawScore : -rawScore;
                scoreObj.score = score;
            }

            // Get PV Move
            const pvIndex = line.indexOf(' pv ');
            if (pvIndex !== -1) {
                scoreObj.move = line.substring(pvIndex + 4).split(' ')[0];
            }

            // Update Line Store
            // If mpv is 1, this is the best line
            multiPvLines[mpv - 1] = scoreObj;

            // Only update Global UI for the primary line (MultiPV 1)
            if (mpv === 1) {
                updateEvalBar(score);
                updateCoachFeedback(score, scoreObj.mate);
                updateEvalHistory(score);
                document.getElementById('best-move-text').innerText = `Best: ${scoreObj.move || '-'}`;
            }

            // Draw Arrows for all valid lines
            drawArrows();
        }

        function updateCoachFeedback(score, mate) {
            const coachText = document.getElementById('coach-text');
            let msg = "";
            let color = "text-slate-300";

            // Coach Logic: Interpret position
            if (mate) {
                msg = mate > 0 ? `White has forced mate in ${mate}!` : `Black has forced mate in ${Math.abs(mate)}!`;
                color = "text-fuchsia-400";
            } else {
                const evalVal = (score / 100).toFixed(2);
                let swing = score - lastEvalScore; // From perspective of White
                
                // If it's Black's turn, a positive swing is bad for Black
                // We want to judge the LAST move made.
                // However, continuous eval just tells us current state.
                
                if (score > 150) { msg = `White is winning (${evalVal}).`; color = "text-emerald-400"; }
                else if (score > 50) { msg = `White is better (${evalVal}).`; color = "text-emerald-200"; }
                else if (score < -150) { msg = `Black is winning (${evalVal}).`; color = "text-rose-400"; }
                else if (score < -50) { msg = `Black is better (${evalVal}).`; color = "text-rose-200"; }
                else { msg = `Position is equal (${evalVal}).`; color = "text-slate-300"; }
            }

            coachText.innerHTML = `<span class="text-amber-500 font-bold">Coach:</span> <span class="${color}">${msg}</span>`;
            
            // Store for next swing calculation only after a move (handled in makeMove)
        }

        function updateEvalBar(score) {
            let capped = Math.max(-500, Math.min(500, score));
            let pct = 50 + (capped / 10);
            document.getElementById('eval-fill').style.height = `${pct}%`;
            document.getElementById('eval-fill').style.backgroundColor = score > 0 ? '#fff' : (score < 0 ? '#171717' : '#999');
            document.getElementById('eval-score').innerText = (score/100).toFixed(2);
            document.getElementById('eval-score').style.color = pct > 50 ? '#000' : '#fff'; 
        }

        function updateEvalHistory(score) {
            const idx = coordMoveList.length;
            const gs = Math.max(-1000, Math.min(1000, score)) / 100;
            evalHistory[idx] = { ply: idx, score: gs };
            drawEvalGraph();
        }

        function drawEvalGraph() {
            const c = document.getElementById('evalGraph'), ctx = c.getContext('2d');
            const w=c.width=c.clientWidth, h=c.height=c.clientHeight;
            ctx.clearRect(0,0,w,h);
            if(!showMetrics || evalHistory.length===0) return;
            const maxS=6, midY=h/2, moves=evalHistory.length, scaleX=w/Math.max(20,moves-1);
            ctx.strokeStyle='#334155'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,midY); ctx.lineTo(w,midY); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle='#10B981'; ctx.lineWidth=2;
            for(let i=0; i<evalHistory.length; i++){
                if(!evalHistory[i])continue;
                const x=evalHistory[i].ply*scaleX;
                const ns=Math.max(-maxS,Math.min(maxS,evalHistory[i].score));
                const y=midY-(ns/maxS*(h/2-5));
                if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke(); ctx.lineTo(w,midY); ctx.lineTo(0,midY); ctx.fillStyle='rgba(16,185,129,0.1)'; ctx.fill();
        }

        // --- Board & Arrows ---
        function drawArrows() {
            const svg = document.getElementById('board-overlay');
            svg.innerHTML = `<defs><marker id="ah" markerWidth="4" markerHeight="3" refX="2" refY="1.5" orient="auto"><polygon points="0 0, 4 1.5, 0 3" fill="context-stroke"/></marker></defs>`;
            
            // Colors for 1st, 2nd, 3rd... best moves
            const colors = [
                'rgba(16, 185, 129, 0.8)', // Green (Best)
                'rgba(59, 130, 246, 0.7)', // Blue
                'rgba(245, 158, 11, 0.7)', // Amber
                'rgba(239, 68, 68, 0.6)',  // Red
                'rgba(107, 114, 128, 0.5)' // Gray
            ];

            multiPvLines.forEach((line, idx) => {
                if (!line || !line.move) return;
                if (idx >= currentMultiPv) return; // Respect slider
                
                const moveStr = line.move;
                const fC=moveStr.charCodeAt(0)-97, fR=8-parseInt(moveStr[1]), tC=moveStr.charCodeAt(2)-97, tR=8-parseInt(moveStr[3]);
                const x1 = (isFlipped ? 7-fC : fC)*12.5+6.25, y1 = (isFlipped ? 7-fR : fR)*12.5+6.25;
                const x2 = (isFlipped ? 7-tC : tC)*12.5+6.25, y2 = (isFlipped ? 7-tR : tR)*12.5+6.25;
                
                const color = colors[idx] || colors[4];
                const width = Math.max(1, 3 - (idx * 0.5)); // Thinner for worse moves

                const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                lineEl.setAttribute('x1', x1); lineEl.setAttribute('y1', y1);
                lineEl.setAttribute('x2', x2); lineEl.setAttribute('y2', y2);
                lineEl.setAttribute('stroke', color);
                lineEl.setAttribute('stroke-width', width);
                lineEl.setAttribute('marker-end', 'url(#ah)');
                svg.appendChild(lineEl);
            });
        }

        // --- Core Chess ---
        function initGame(custom=null) {
            if(custom) board=custom;
            else {
                board=Array(8).fill(null).map(()=>Array(8).fill(null));
                const b=['r','n','b','q','k','b','n','r'];
                for(let c=0;c<8;c++){ board[1][c]={type:'p',color:'b'}; board[6][c]={type:'p',color:'w'}; board[0][c]={type:b[c],color:'b'}; board[7][c]={type:b[c],color:'w'}; }
            }
            turn='w'; castlingRights={w:{k:true,q:true},b:{k:true,q:true}};
            enPassantTarget=null; fullMoveNumber=1; moveList=[]; coordMoveList=[];
            historyStack=[]; positionHistory={}; capturedPieces={w:[],b:[]};
            lastMove=null; isGameOver=false; pendingPromotion=null;
            evalHistory=[{ply:0,score:0.1}]; multiPvLines=[]; lastEvalScore=0;
            
            if(gameMode==='960'){
                ['w','b'].forEach(c=>{
                    const r=c==='w'?7:0; let k=-1;
                    for(let i=0;i<8;i++)if(board[r][i]?.type==='k')k=i;
                    if(k!==-1){ for(let i=0;i<k;i++)if(board[r][i]?.type==='r')rooks960[c].q=i; for(let i=k+1;i<8;i++)if(board[r][i]?.type==='r')rooks960[c].k=i; }
                });
            }
            document.getElementById('game-over-modal').classList.add('hidden');
            document.getElementById('promotion-modal').classList.add('hidden');
            isEnginePaused=true; renderBoard(); updateUI(); playSound('start'); triggerEngine();
        }

        function setGameMode(m){ gameMode=m; document.getElementById('960-controls').classList.toggle('hidden',m!=='960'); if(m==='classical')initGame(); }
        function startChess960(){
            const inp=document.getElementById('960-id').value; let id=inp===""?Math.floor(Math.random()*960):parseInt(inp);
            if(id<0||id>959)id=Math.floor(Math.random()*960);
            let r=Array(8).fill(null), b1=id%4, rem=Math.floor(id/4); r[b1*2+1]='b';
            let b2=rem%4; rem=Math.floor(rem/4); r[b2*2]='b';
            let q=rem%6; rem=Math.floor(rem/6); let e=[]; for(let i=0;i<8;i++)if(!r[i])e.push(i); r[e[q]]='q';
            const nt=[[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]];
            let n=rem%10; rem=Math.floor(rem/10); e=[]; for(let i=0;i<8;i++)if(!r[i])e.push(i); r[e[nt[n][0]]]='n'; r[e[nt[n][1]]]='n';
            e=[]; for(let i=0;i<8;i++)if(!r[i])e.push(i); r[e[0]]='r'; r[e[1]]='k'; r[e[2]]='r';
            board=Array(8).fill(null).map(()=>Array(8).fill(null));
            for(let c=0;c<8;c++){ board[1][c]={type:'p',color:'b'}; board[6][c]={type:'p',color:'w'}; board[0][c]={type:r[c],color:'b'}; board[7][c]={type:r[c],color:'w'}; }
            initGame(board);
        }

        // --- Move Logic ---
        function getPiece(r,c){return (r>=0&&r<8&&c>=0&&c<8)?board[r][c]:null;}
        function getPseudoMoves(r,c,p){
            let m=[]; const f=p.color==='w'?-1:1;
            if(p.type==='p'){
                if(!getPiece(r+f,c)){ m.push({r:r+f,c:c}); if((p.color==='w'&&r===6)||(p.color==='b'&&r===1))if(!getPiece(r+f*2,c))m.push({r:r+f*2,c:c,dbl:true}); }
                [[r+f,c-1],[r+f,c+1]].forEach(([tr,tc])=>{ const t=getPiece(tr,tc); if((t&&t.color!==p.color)||(enPassantTarget&&tr===enPassantTarget.r&&tc===enPassantTarget.c))m.push({r:tr,c:tc,ep:!t}); });
            } else if(['n','k'].includes(p.type)){
                const s=p.type==='n'?[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]:[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                s.forEach(([dr,dc])=>{const tr=r+dr,tc=c+dc; if(tr>=0&&tr<8&&tc>=0&&tc<8){const t=getPiece(tr,tc); if(!t||t.color!==p.color||(gameMode==='960'&&t.type==='r'&&t.color===p.color))m.push({r:tr,c:tc});}});
                if(p.type==='k'){
                    if(gameMode==='classical'){
                        if(castlingRights[p.color].k&&!getPiece(r,c+1)&&!getPiece(r,c+2)&&board[r][7]?.type==='r')m.push({r:r,c:c+2,castle:'k'});
                        if(castlingRights[p.color].q&&!getPiece(r,c-1)&&!getPiece(r,c-2)&&!getPiece(r,c-3)&&board[r][0]?.type==='r')m.push({r:r,c:c-2,castle:'q'});
                    } else {
                        const rK=rooks960[p.color].k, rQ=rooks960[p.color].q;
                        if(castlingRights[p.color].k&&rK!==null){
                            let b=false; for(let i=Math.min(c,rK)+1;i<Math.max(c,rK);i++)if(board[r][i])b=true;
                            for(let i=Math.min(c,6);i<=Math.max(c,6);i++)if(i!==c&&i!==rK&&board[r][i])b=true; for(let i=Math.min(rK,5);i<=Math.max(rK,5);i++)if(i!==c&&i!==rK&&board[r][i])b=true;
                            if(!b)m.push({r:r,c:rK,castle:'k',is960:true});
                        }
                        if(castlingRights[p.color].q&&rQ!==null){
                            let b=false; for(let i=Math.min(c,rQ)+1;i<Math.max(c,rQ);i++)if(board[r][i])b=true;
                            for(let i=Math.min(c,2);i<=Math.max(c,2);i++)if(i!==c&&i!==rQ&&board[r][i])b=true; for(let i=Math.min(rQ,3);i<=Math.max(rQ,3);i++)if(i!==c&&i!==rQ&&board[r][i])b=true;
                            if(!b)m.push({r:r,c:rQ,castle:'q',is960:true});
                        }
                    }
                }
            } else {
                const d=p.type==='b'?[[-1,-1],[-1,1],[1,-1],[1,1]]:p.type==='r'?[[-1,0],[1,0],[0,-1],[0,1]]:[[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
                d.forEach(([dr,dc])=>{let tr=r+dr,tc=c+dc;while(tr>=0&&tr<8&&tc>=0&&tc<8){const t=getPiece(tr,tc);if(!t)m.push({r:tr,c:tc});else{if(t.color!==p.color)m.push({r:tr,c:tc});break;}tr+=dr;tc+=dc;}});
            }
            return m;
        }

        function getLegalMoves(r,c){
            const p=getPiece(r,c); if(!p)return[];
            return getPseudoMoves(r,c,p).filter(m=>{
                const bk={o:board[r][c],d:board[m.r][m.c],e:m.ep?board[r][m.c]:null};
                let kD=m.castle==='k'?6:2, rD=m.castle==='k'?5:3, rS=m.c;
                if(m.is960){ board[r][c]=null; board[r][rS]=null; board[r][kD]={type:'k',color:p.color}; board[r][rD]={type:'r',color:p.color}; }
                else { board[m.r][m.c]=board[r][c]; board[r][c]=null; if(m.ep)board[r][m.c]=null; }
                let s=!isInCheck(p.color);
                if(m.castle){
                    if(!m.is960){const step=(m.c>c)?1:-1; if(isInCheck(p.color)||isSqAtk(p.color,r,c+step))s=false;}
                    else{const step=kD>c?1:-1; if(isInCheck(p.color))s=false; if(c!==kD){let curr=c+step;while(curr!==kD+step){if(isSqAtk(p.color,r,curr))s=false;curr+=step;}}}
                }
                if(m.is960){ board[r][kD]=null; board[r][rD]=null; board[r][c]=bk.o; board[m.r][m.c]=bk.d; }
                else { board[m.r][m.c]=bk.d; board[r][c]=bk.o; if(m.ep)board[r][m.c]=bk.e; }
                return s;
            });
        }
        function isSqAtk(c,r,k){const op=c==='w'?'b':'w';for(let i=0;i<8;i++)for(let j=0;j<8;j++)if(board[i][j]?.color===op)if(getPseudoMoves(i,j,board[i][j]).some(m=>m.r===r&&m.c===k&&!m.castle))return true;return false;}
        function isInCheck(c){let k;for(let i=0;i<8;i++)for(let j=0;j<8;j++)if(board[i][j]?.type==='k'&&board[i][j].color===c)k={r:i,c:j};return k?isSqAtk(c,k.r,k.c):false;}

        function makeMove(f,m,eng=false,pro='q'){
            const p=board[f.r][f.c]; if(!p)return;
            if(p.type==='p'&&(m.r===0||m.r===7)&&!eng&&!pendingPromotion&&pro==='q'){pendingPromotion={from:f,move:m};showProm(p.color);return;}
            saveState();
            
            // Record last eval before move for Coach
            const latestEval = multiPvLines[0]?.score || 0;
            lastEvalScore = latestEval;

            let dest=board[m.r][m.c], cap=(dest&&!m.is960)||m.ep, san=SAN_PIECES[p.type];
            if(m.castle==='k')san='O-O'; else if(m.castle==='q')san='O-O-O';
            else { if(cap||(p.type==='p'&&cap)){if(p.type==='p')san+=getFile(f);san+='x';} san+=getCoord(m); }
            let uci=getCoord(f)+(m.is960?getCoord({r:m.r,c:m.c}):getCoord(m)); if(p.type==='p'&&(m.r===0||m.r===7))uci+=pro;
            coordMoveList.push(uci);
            playSound(cap||m.ep?'capture':'move');
            
            if(m.is960){
                let kD=m.castle==='k'?6:2, rD=m.castle==='k'?5:3;
                board[f.r][f.c]=null; board[m.r][m.c]=null; board[m.r][kD]=p; board[m.r][rD]={type:'r',color:p.color};
                castlingRights[p.color]={k:false,q:false};
            } else {
                if(dest&&!m.is960){ capturedPieces[dest.color].push(PIECES[dest.color][dest.type]); if(dest.type==='r'){if(m.c===0)castlingRights[dest.color].q=false;if(m.c===7)castlingRights[dest.color].k=false;} }
                if(m.ep){const ep=board[f.r][m.c];capturedPieces[ep.color].push(PIECES[ep.color][ep.type]);board[f.r][m.c]=null;}
                board[m.r][m.c]=p; board[f.r][f.c]=null;
                if(m.castle==='k'){board[f.r][5]=board[f.r][7];board[f.r][7]=null;} if(m.castle==='q'){board[f.r][3]=board[f.r][0];board[f.r][0]=null;}
                if(p.type==='p'&&(m.r===0||m.r===7)){p.type=pro;san+="="+pro.toUpperCase();}
            }
            enPassantTarget=m.dbl?{r:(f.r+m.r)/2,c:f.c}:null;
            if(p.type==='p'||cap)halfMoveClock=0;else halfMoveClock++; if(turn==='b')fullMoveNumber++;
            turn=turn==='w'?'b':'w'; lastMove={from:f,to:m};
            if(p.type==='k')castlingRights[p.color]={k:false,q:false};
            if(p.type==='r'){if(gameMode==='classical'){if(f.c===0)castlingRights[p.color].q=false;if(f.c===7)castlingRights[p.color].k=false;}else{if(f.c===rooks960[p.color].q)castlingRights[p.color].q=false;if(f.c===rooks960[p.color].k)castlingRights[p.color].k=false;}}
            
            const chk=isInCheck(turn);
            if(chk){if(!hasMoves(turn)){san+="#";playSound('mate');}else{san+="+";playSound('check');}}else if(!hasMoves(turn))playSound('draw');
            moveList.push(san); updateRep(); renderBoard(); updateUI(); pendingPromotion=null;
            document.getElementById('promotion-modal').classList.add('hidden');
            checkOver(chk); triggerEngine();
        }

        // --- Engine Control ---
        function startEngine(){ if(isGameOver)return showMessage("Game Over"); isEnginePaused=false; document.getElementById('engine-status-text').innerText="Engine: Starting..."; triggerEngine(); }
        function stopEngine(){ isEnginePaused=true; document.getElementById('engine-status-text').innerText="Engine: Stopped"; if(stockfish)stockfish.postMessage('stop'); if(engineTimeout)clearTimeout(engineTimeout); toggleThinkingSound(false); playSound('stop'); }
        
        function triggerEngine(){
            if(!stockfish||!isEngineReady||isGameOver)return;
            if(engineTimeout)clearTimeout(engineTimeout);
            const fen=getFEN(), comp=isComputerTurn();
            if(isEnginePaused)return;
            
            const mode = document.querySelector('input[name="engine-mode"]:checked').value;
            let cmd='';
            
            if(comp){
                document.getElementById('engine-status-text').innerText="Engine: Thinking...";
                toggleThinkingSound(true);
                // Active Play: Use configured settings
                if (mode === 'time') {
                    const ms = parseInt(document.getElementById('engine-time-ms').value) || 1000;
                    cmd = `go movetime ${ms}`;
                } else {
                    const d = parseInt(document.getElementById('engine-depth-val').value) || 15;
                    cmd = `go depth ${d}`;
                }
            } else {
                document.getElementById('engine-status-text').innerText="Engine: Analyzing...";
                toggleThinkingSound(false);
                // Passive Analysis: Always depth 20 for quality arrows unless user wants deep deep analysis
                cmd = `go depth 20`; 
            }
            stockfish.postMessage(`position fen ${fen}`);
            stockfish.postMessage(cmd);
        }

        function applyEngineMove(best){
            const fC=best.charCodeAt(0)-97, fR=8-parseInt(best[1]), tC=best.charCodeAt(2)-97, tR=8-parseInt(best[3]);
            const m=getLegalMoves(fR,fC).find(v=>(v.is960&&v.castle)?(v.r===tR&&v.c===tC):(v.r===tR&&v.c===tC));
            let pro=best.length===5?best[4]:'q';
            if(m) setTimeout(()=>makeMove({r:fR,c:fC},m,true,pro),250);
        }

        function isComputerTurn(){ return (turn==='w'&&document.getElementById('white-player').value==='stockfish')||(turn==='b'&&document.getElementById('black-player').value==='stockfish'); }
        function saveState(){ historyStack.push({board:JSON.parse(JSON.stringify(board)),turn,castlingRights:JSON.parse(JSON.stringify(castlingRights)),rooks960:JSON.parse(JSON.stringify(rooks960)),enPassantTarget,lastMove,moveList:[...moveList],coordMoveList:[...coordMoveList],capturedPieces:JSON.parse(JSON.stringify(capturedPieces)),positionHistory:JSON.parse(JSON.stringify(positionHistory)),evalHistory:[...evalHistory]}); }
        function undoMove(){ 
            if(historyStack.length===0)return; 
            if(isComputerTurn())stopEngine(); 
            playSound('undo'); const s=historyStack.pop(); 
            board=s.board;turn=s.turn;lastMove=s.lastMove;moveList=s.moveList;coordMoveList=s.coordMoveList;castlingRights=s.castlingRights;enPassantTarget=s.enPassantTarget;rooks960=s.rooks960||rooks960;capturedPieces=s.capturedPieces;positionHistory=s.positionHistory;evalHistory=s.evalHistory;
            renderBoard();updateUI();document.getElementById('board-overlay').innerHTML='';triggerEngine();drawEvalGraph();
        }

        // --- Utils ---
        function getFEN(){
            let fen=""; for(let r=0;r<8;r++){let e=0;for(let c=0;c<8;c++){const p=board[r][c];if(!p)e++;else{if(e){fen+=e;e=0;}fen+=p.color==='w'?p.type.toUpperCase():p.type.toLowerCase();}}if(e)fen+=e;if(r<7)fen+="/";}
            fen+=` ${turn} `; let c="";if(castlingRights.w.k)c+="K";if(castlingRights.w.q)c+="Q";if(castlingRights.b.k)c+="k";if(castlingRights.b.q)c+="q";
            fen+=(c||"-")+" "; fen+=(enPassantTarget?getCoord(enPassantTarget):"-")+" "; fen+=`${halfMoveClock} ${fullMoveNumber}`; return fen;
        }
        function handleClick(r,c){
            initSound(); if(isGameOver)return showMessage("Game Over"); if(isComputerTurn()&&!isEnginePaused)return;
            const p=board[r][c];
            if(selectedSquare){
                const m=getLegalMoves(selectedSquare.r,selectedSquare.c).find(v=>v.r===r&&v.c===c);
                if(m){makeMove(selectedSquare,m);selectedSquare=null;return;}
                else if(p&&p.color===turn){selectedSquare={r,c};renderBoard();return;}
                selectedSquare=null;renderBoard();return;
            }
            if(p&&p.color===turn){selectedSquare={r,c};renderBoard();}
        }
        function getCoord(o){return String.fromCharCode(97+o.c)+(8-o.r);}
        function getFile(o){return String.fromCharCode(97+o.c);}
        function showMessage(t){const b=document.getElementById('message-box');b.innerText=t;b.classList.add('show');setTimeout(()=>b.classList.remove('show'),3000);}
        function flipBoard(){isFlipped=!isFlipped;renderBoard();playSound('flip');if(showMetrics)triggerEngine();}
        function toggleMetrics(){
            showMetrics=document.getElementById('metrics-toggle').checked;
            document.getElementById('eval-bar-wrapper').classList.toggle('opacity-0',!showMetrics);
            document.getElementById('graph-container').classList.toggle('opacity-0',!showMetrics);
            document.getElementById('coach-box').classList.toggle('opacity-0',!showMetrics);
            triggerEngine(); drawEvalGraph();
        }
        function resetGame(){if(gameMode==='960')startChess960();else initGame();}
        function updateSettings(){updateEloDisplay();triggerEngine();}
        function copyPGN(){let p="";for(let i=0;i<moveList.length;i+=2){p+=`${(i/2)+1}. ${moveList[i]} `;if(moveList[i+1])p+=`${moveList[i+1]} `;}if(p){const t=document.createElement('textarea');t.value=p.trim();document.body.appendChild(t);t.select();document.execCommand('copy');document.body.removeChild(t);showMessage("PGN Copied");}}
        
        function renderBoard(){
            const el=document.getElementById('board');el.innerHTML='';
            const R=isFlipped?[7,6,5,4,3,2,1,0]:[0,1,2,3,4,5,6,7], C=isFlipped?[7,6,5,4,3,2,1,0]:[0,1,2,3,4,5,6,7];
            let pm=selectedSquare?getLegalMoves(selectedSquare.r,selectedSquare.c):[];
            R.forEach(r=>C.forEach(c=>{
                const d=document.createElement('div');
                let cls=`square relative flex items-center justify-center text-4xl sm:text-5xl ${(r+c)%2===0?'bg-[#EBECD0] text-black':'bg-[#779556] text-black'} `;
                if(lastMove&&((lastMove.from.r===r&&lastMove.from.c===c)||(lastMove.to.r===r&&lastMove.to.c===c)))cls+=' last-move';
                if(selectedSquare&&selectedSquare.r===r&&selectedSquare.c===c)cls+=' selected';
                const im=pm.find(m=>m.r===r&&m.c===c); if(im)cls+=(board[r][c]||im.ep)?' capture-move':(im.is960?' possible-move':' possible-move');
                d.className=cls; d.onclick=()=>handleClick(r,c);
                const p=board[r][c];
                if(p){const s=document.createElement('span');s.className='chess-piece drop-shadow-md';s.innerText=PIECES[p.color][p.type];if(p.color==='w'){s.style.color=whitePieceColor;s.style.textShadow=whitePieceShadow;}else{s.style.color='#000';s.style.textShadow='none';}d.appendChild(s);}
                el.appendChild(d);
            }));
            if(showMetrics)drawArrows();
        }

        function updateUI(){
            document.getElementById('status-badge').innerText=turn==='w'?"White's Turn":"Black's Turn";
            document.getElementById('captured-white').innerHTML=capturedPieces.w.join(' ');
            document.getElementById('captured-black').innerHTML=capturedPieces.b.join(' ');
            const h=document.getElementById('move-history');
            if(moveList.length===0)h.innerHTML='<div class="text-slate-500 italic text-center mt-4">Game Start</div>';
            else{let ht='<div class="grid grid-cols-[30px_1fr_1fr] gap-y-1 p-2">';for(let i=0;i<moveList.length;i+=2){ht+=`<div class="text-slate-500 text-xs pt-1">${(i/2)+1}.</div><div class="bg-slate-800 px-2 py-0.5 rounded text-slate-300 hover:bg-slate-700 cursor-pointer transition">${moveList[i]}</div>`;if(moveList[i+1])ht+=`<div class="bg-slate-800 px-2 py-0.5 rounded text-slate-300 hover:bg-slate-700 cursor-pointer transition">${moveList[i+1]}</div>`;}ht+='</div>';h.innerHTML=ht;h.scrollTop=h.scrollHeight;}
        }

        function checkOver(chk){
            if(hasRep()){isGameOver=true;showRes("Draw (Repetition)",'text-slate-300');playSound('draw');return;}
            if(halfMoveClock>=100){isGameOver=true;showRes("Draw (50-move)",'text-slate-300');playSound('draw');return;}
            if(hasMat()){isGameOver=true;showRes("Draw (Material)",'text-slate-300');playSound('draw');return;}
            if(!hasMoves(turn)){isGameOver=true;if(chk)showRes(`Checkmate! ${turn==='w'?'Black':'White'} wins!`,'text-green-400');else{showRes("Stalemate",'text-slate-300');playSound('draw');}}
        }
        function showRes(t,c){const m=document.getElementById('game-over-modal'),g=document.getElementById('game-result');m.classList.remove('hidden');g.innerText=t;g.className=`text-3xl font-bold ${c} mb-2`;}
        function updateRep(){const f=getFEN();positionHistory[f]=(positionHistory[f]||0)+1;}
        function hasRep(){const f=getFEN();return positionHistory[f]>=3;}
        function hasMat(){const p=[];for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(board[r][c])p.push(board[r][c]);if(p.length===2)return true;if(p.length===3){const x=p.find(z=>z.type!=='k');if(x.type==='n'||x.type==='b')return true;}return false;}
        function hasMoves(c){for(let i=0;i<8;i++)for(let j=0;j<8;j++)if(board[i][j]?.color===c&&getLegalMoves(i,j).length>0)return true;return false;}
        function showProm(c){const m=document.getElementById('promotion-modal'),o=document.getElementById('promo-options');o.innerHTML='';['q','r','b','n'].forEach(t=>{const b=document.createElement('div');b.className='promo-option text-white bg-slate-700 p-4 rounded-lg shadow hover:bg-slate-600';b.innerText=PIECES[c][t];b.onclick=()=>completeProm(t);o.appendChild(b);});m.classList.remove('hidden');}
        function completeProm(t){if(pendingPromotion){const{from,move}=pendingPromotion;makeMove(from,move,false,t);}}
        
        window.onload=()=>{initEngine();initGame();}
    </script>
</body>
</html>
